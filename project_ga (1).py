# -*- coding: utf-8 -*-
"""project GA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13blDwfR4-Rl1COx9W1hw_zj749XAe8vC
"""

import random

import numpy as np

# Objective function
def objective(x):
    h = x[0]
    l = x[1]
    t = x[2]
    b = x[3]
    return 1.0471 * h**2 * l + 0.04811 * t * b * (14.0 + l)

# Constraints
def constraints(x):
    h = x[0]
    l = x[1]
    t = x[2]
    b = x[3]
    t1x = 6000 / (np.sqrt(2) * h * l)
    t2x = (6000 * (14 + 0.5 * l) * np.sqrt(0.25 * ((l**2 + (h + t)**2)))) / (2 * (0.707 * h * l) * (l**2 / 12 + 0.25 * (h + t)**2))
    ax = 504000 / (t**2) * b
    pcx = 64746.022 * (1 - 0.0282346 * t) * t * (b**3)
    gx = (2.195**2) / (t**3) * b
    tx = np.sqrt((t1x**2) + (t2x**2) + l * t1x * t2x) / np.sqrt(0.25 * (l**2 + (h + t)**2))
    constraints = [
        h >= 0.125,
        h <= 10,
        l >= 0.1,
        l <= 10,
        t >= 0.1,
        t <= 10,
        b >= 0.1,
        b <= 10,
        tx <= 13600,
        ax <= 30000,
        pcx <= 6000,
        gx >= 0.25
    ]
    return all(constraints)

# Genetic Algorithm
def genetic_algorithm(objective, constraints, bounds, pop_size=100, generations=100, mutation_rate=0.1):
    best_solution = None
    best_fitness = np.inf

    for gen in range(generations):
        # Generate initial population
        pop = np.random.uniform(bounds[:, 0], bounds[:, 1], size=(pop_size, len(bounds)))

        # Evaluate fitness
        feasible = np.array([constraints(ind) for ind in pop])
        feasible_pop = pop[feasible]
        if len(feasible_pop) == 0:
            continue  # Skip this generation if no feasible individuals
        fitness = np.array([objective(ind) for ind in feasible_pop])
        min_feasible_fitness = np.min(fitness)
        min_feasible_index = np.argmin(fitness)

        # Update best solution
        if min_feasible_fitness < best_fitness:
            best_fitness = min_feasible_fitness
            best_solution = feasible_pop[min_feasible_index]

        # Selection
        selected_indices = np.random.choice(np.arange(len(feasible_pop)), size=pop_size, replace=True, p=fitness / np.sum(fitness))

        # Crossover
        parents = feasible_pop[selected_indices]
        crossover_point = np.random.randint(1, len(bounds) - 1, size=pop_size)
        children = np.empty_like(parents)
        for i in range(pop_size):
            crossover_idx = crossover_point[i]
            children[i] = np.concatenate([parents[i][:crossover_idx], parents[(i+1)%pop_size][crossover_idx:]])

        # Mutation
        mask = np.random.rand(*children.shape) < mutation_rate
        children[mask] = np.random.uniform(bounds[:, 0], bounds[:, 1], size=np.count_nonzero(mask))

    return best_solution, best_fitness

# Define bounds for variables
bounds = np.array([[0.1, 10],  # h
                   [0.1, 10],  # l
                   [0.1, 10],  # t
                   [0.1, 10]]) # b

# Run genetic algorithm with increased parameters
best_solution, best_fitness = genetic_algorithm(objective, constraints, bounds, pop_size=100, generations=500, mutation_rate=0.2)

# Print results
if best_solution is not None:
    print("Best Solution:")
    print("h:", best_solution[0])
    print("l:", best_solution[1])
    print("t:", best_solution[2])
    print("b:", best_solution[3])
    print("Best Fitness:", best_fitness)
else:
    print("No feasible solution found.")

#problem 1
import numpy as np
import random

# Define the objective function
def objective(x):
    x1 = x[0]
    x2 = x[1]
    return (x1 - 3)**2 + (x2 - 2)**2

# Define the constraints
def constraint1(x):
    return x[0]**2 - x[1] - 3.0

def constraint2(x):
    return -x[1] + 1

def constraint3(x):
    return x[0]

# Genetic Algorithm Parameters
pop_size = 500
num_generations = 500
mutation_rate = 0.1

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(-10, 10, size=2)
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-1, 1)
            if i == 0:
                individual[i] = max(0, individual[i])  # constraint3
            else:
                individual[i] = max(0, individual[i])  # constraint2
                individual[i] = max(individual[0]**2 - 3.0, individual[i])  # constraint1
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

import numpy as np
import random

# Define the objective function
def objective(x):
    x1 = x[0]
    x2 = x[1]
    return (x1 - 3)**2 + (x2 - 2)**2

# Define the constraints
def constraint1(x):
    return x[0]**2 - x[1] - 3.0

def constraint2(x):
    return -x[1] + 1

def constraint3(x):
    return x[0]

# Genetic Algorithm Parameters
pop_size = 250
num_generations = 250
mutation_rate = 0.01
crossover_rate = 0.8  # Define crossover rate

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(-10, 10, size=2)
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    if random.random() < crossover_rate:  # Perform crossover based on crossover rate
        crossover_point = random.randint(1, len(parent1) - 1)
        child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
        child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
        return child1, child2
    else:
        return parent1, parent2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-1, 1)
            if i == 0:
                individual[i] = max(0, individual[i])  # constraint3
            else:
                individual[i] = max(0, individual[i])  # constraint2
                individual[i] = max(individual[0]**2 - 3.0, individual[i])  # constraint1
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate, crossover_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate, crossover_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

#problem 1
import numpy as np
import random

# Define the objective function
def objective(x):
    x1 = x[0]
    x2 = x[1]
    return (x1 - 1.5)**2 + (x2 - 5)**2

# Define the constraints
def constraint1(x):
    return x[0] - x[1] + 2.0

def constraint2(x):
    return x[1]

def constraint3(x):
    return x[0]

# Genetic Algorithm Parameters
pop_size = 500
num_generations = 500
mutation_rate = 0.1

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(-10, 10, size=2)
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-1, 1)
            if i == 0:
                individual[i] = max(0, individual[i])  # constraint3
            else:
                individual[i] = max(0, individual[i])  # constraint2
                individual[i] = max(individual[0]**2 - 3.0, individual[i])  # constraint1
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

import numpy as np
import random

# Define the objective function
def objective(x):
    x1 = x[0]
    x2 = x[1]
    return (x1 - 1.5)**2 + (x2 - 5)**2

# Define the constraints
def constraint1(x):
    return x[0] - x[1] + 2.0

def constraint2(x):
    return x[1]

def constraint3(x):
    return x[0]

# Genetic Algorithm Parameters
pop_size = 500
num_generations = 500
mutation_rate = 0.1
crossover_rate = 0.8  # Define crossover rate

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(-10, 10, size=2)
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    if random.random() < crossover_rate:  # Perform crossover based on crossover rate
        crossover_point = random.randint(1, len(parent1) - 1)
        child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
        child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
        return child1, child2
    else:
        return parent1, parent2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-1, 1)
            if i == 0:
                individual[i] = max(0, individual[i])  # constraint3
            else:
                individual[i] = max(0, individual[i])  # constraint2
                individual[i] = max(individual[0]**2 - 3.0, individual[i])  # constraint1
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate, crossover_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate, crossover_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

#problem 2
import numpy as np
from scipy.optimize import minimize
import random

# Define the objective function
def objective(x):
    x1 = x[0]
    x2 = x[1]
    return (x1 - 1.5)**2 + (x2 - 5)**2

# Define the constraints
def constraint1(x):
    return x[0] - x[1] + 2

def constraint2(x):
    return -2*x[0] - 3*x[1] + 11

def constraint3(x):
    return x[0]

def constraint4(x):
    return x[1]

# Genetic Algorithm Parameters
pop_size = 500
num_generations = 500
mutation_rate = 0.1

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(-10, 10, size=2)
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0 and constraint4(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-1, 1)
            if i == 0:
                individual[i] = max(0, individual[i])  # constraint3
            else:
                individual[i] = max(0, individual[i])  # constraint4
                if i == 0:  # constraint1
                    individual[i] = max(individual[i] - individual[1] + 2, individual[i])
                else:  # constraint2
                    individual[i] = max((-2 * individual[0] - 3 * individual[i] + 11) / (-3), individual[i])
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

import numpy as np
import random

# Define the objective function
def objective(x):
    x1 = x[0]
    x2 = x[1]
    return (x1 - 1.5)**2 + (x2 - 5)**2

# Define the constraints
def constraint1(x):
    return x[0] - x[1] + 2

def constraint2(x):
    return -2*x[0] - 3*x[1] + 11

def constraint3(x):
    return x[0]

def constraint4(x):
    return x[1]

# Genetic Algorithm Parameters
pop_size = 500
num_generations = 500
mutation_rate = 0.1
crossover_rate = 0.8  # Define crossover rate

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(-10, 10, size=2)
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0 and constraint4(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    if random.random() < crossover_rate:  # Perform crossover based on crossover rate
        crossover_point = random.randint(1, len(parent1) - 1)
        child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
        child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
        return child1, child2
    else:
        return parent1, parent2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-1, 1)
            if i == 0:
                individual[i] = max(0, individual[i])  # constraint3
            else:
                individual[i] = max(0, individual[i])  # constraint4
                if i == 0:  # constraint1
                    individual[i] = max(individual[i] - individual[1] + 2, individual[i])
                else:  # constraint2
                    individual[i] = max((-2 * individual[0] - 3 * individual[i] + 11) / (-3), individual[i])
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate, crossover_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate, crossover_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

#PROBLEM 3
import numpy as np
from scipy.optimize import minimize
import random

# Define the objective function
def objective(x):
    x1 = x[0]
    x2 = x[1]
    return (x1 - 1)**2 + (x2 - 1)**2

# Define the constraints
def constraint1(x):
    return -(x[0] + x[1] - 1)**3

def constraint2(x):
    return x[0]

def constraint3(x):
    return x[1]

# Genetic Algorithm Parameters
pop_size = 100
num_generations = 100
mutation_rate = 0.1

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(-10, 10, size=2)
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-1, 1)
            if i == 0:
                individual[i] = max(0, individual[i])  # constraint2
                individual[i] = min(1, individual[i])  # constraint1
            else:
                individual[i] = max(0, individual[i])  # constraint3
                individual[i] = min(1, individual[i])  # constraint1
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

#PROBLEM NUMBER 4

import numpy as np
import random
import math

# Define the objective function
def objective(x):
    return 1 - x[0] + x[1]**2 - 0.1 * math.sin(3 * math.pi * x[0])

# Define the constraint
def constraint1(x, a):
    return -x[0] + a

# Genetic Algorithm Parameters
pop_size = 500
num_generations = 500
mutation_rate = 0.01

# Function to generate initial population with constraints
def generate_initial_population(pop_size, a):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform([0, -2], [1, 2])
        if constraint1(individual, a) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate, a):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-0.1, 0.1)
            if i == 0:
                individual[i] = max(0, individual[i])  # Constraint
                individual[i] = min(1, individual[i])  # Constraint
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate, a):
    population = generate_initial_population(pop_size, a)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate, a)
            child2 = mutation(child2, mutation_rate, a)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
a = 0.226
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate, a)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

#PROBLEM NUMBER 4
import numpy as np
import random
import math

# Define the objective function
def objective(x):
    return 1 - x[0] + x[1]**2 - 0.1 * math.sin(3 * math.pi * x[0])

# Define the constraints for 'a'
def constraint1(x):
    return -x[0] + 0.441  # Upper bound for 'a'

def constraint2(x):
    return x[0] - 0.226  # Lower bound for 'a'

# Genetic Algorithm Parameters
pop_size = 100
num_generations = 100
mutation_rate = 0.1

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform([0, -2], [1, 2])
        if constraint1(individual) >= 0 and constraint2(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-0.1, 0.1)
            if i == 0:
                individual[i] = max(0, individual[i])  # Constraint
                individual[i] = min(1, individual[i])  # Constraint
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

# 5
import numpy as np
import random
from math import sqrt

# Define the objective function
def objective(x):
    h = x[0]
    l = x[1]
    t = x[2]
    b = x[3]
    return 1.0471 * h**2 * l + 0.04811 * t * b * (14.0 + l)

# Define the constraints
def constraint1(x):
    return -x[0] + 10  # Upper bound for 'h'

def constraint2(x):
    return x[0] - 0.125  # Lower bound for 'h'

def constraint3(x):
    return -x[1] + 10  # Upper bound for 'l'

def constraint4(x):
    return x[1] - 0.1  # Lower bound for 'l'

def constraint5(x):
    return x[2] * x[3] + 13600

def constraint6(x):
    return 504000 / x[2]**2 * x[3] + 30000

def constraint7(x):
    return -x[0] + x[3]

def constraint8(x):
    return 64746.022 * (1 - 0.0282346 * x[2]) * x[2] * x[3]**3 + 6000

def constraint9(x):
    return 2.195**2 / x[2]**3 * x[3] - 0.25

# Genetic Algorithm Parameters
pop_size = 500
num_generations = 500
mutation_rate = 0.01

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform([0.125, 0.1, 0.1, 0.1], [10, 10, 10, 10])
        if constraint1(individual) >= 0 and constraint2(individual) >= 0 and constraint3(individual) >= 0 and \
                constraint4(individual) >= 0 and constraint5(individual) >= 0 and constraint6(individual) >= 0 and \
                constraint7(individual) >= 0 and constraint8(individual) >= 0 and constraint9(individual) >= 0:
            population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[:pop_size]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

# Function to perform mutation with constraints
def mutation(individual, mutation_rate):
    for i in range(len(individual)):
        if random.random() < mutation_rate:
            individual[i] += np.random.uniform(-0.1, 0.1)
            individual[i] = max(0.125, individual[i]) if i == 0 else individual[i]
            individual[i] = min(10, individual[i]) if i == 0 else individual[i]
            individual[i] = max(0.1, individual[i]) if i == 1 else individual[i]
            individual[i] = min(10, individual[i]) if i == 1 else individual[i]
            individual[i] = max(0.1, individual[i]) if i == 2 else individual[i]
            individual[i] = min(10, individual[i]) if i == 2 else individual[i]
            individual[i] = max(0.1, individual[i]) if i == 3 else individual[i]
            individual[i] = min(10, individual[i]) if i == 3 else individual[i]
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solution = min(population, key=objective)
    return best_solution, objective(best_solution)

# Running the Genetic Algorithm
best_solution, best_fitness = genetic_algorithm(pop_size, num_generations, mutation_rate)

# Printing the result
print("Best solution found by Genetic Algorithm:", best_solution)
print("Objective value at the best solution:", best_fitness)

# 6
import numpy as np
import random
import math

# Define the objective function
def objective(x):
    return abs(math.sin(math.pi * x))

# Genetic Algorithm Parameters
pop_size = 100
num_generations = 100
mutation_rate = 0.1

# Function to generate initial population with constraints
def generate_initial_population(pop_size):
    population = []
    while len(population) < pop_size:
        individual = np.random.uniform(0, 2)
        population.append(individual)
    return population

# Function to evaluate the fitness of each individual in the population
def evaluate_population(population):
    fitness = []
    for individual in population:
        fitness.append(objective(individual))
    return fitness

# Function to perform selection based on fitness
def selection(population, fitness):
    selected_population = [population[i] for i in np.argsort(fitness)[-pop_size:]]
    return selected_population

# Function to perform crossover
def crossover(parent1, parent2):
    crossover_point = random.randint(0, len(parent1) - 1)
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2

# Function to perform mutation
def mutation(individual, mutation_rate):
    if random.random() < mutation_rate:
        individual += np.random.uniform(-0.1, 0.1)
        individual = max(0, individual)
        individual = min(2, individual)
    return individual

# Main Genetic Algorithm
def genetic_algorithm(pop_size, num_generations, mutation_rate):
    population = generate_initial_population(pop_size)
    for _ in range(num_generations):
        fitness = evaluate_population(population)
        selected_population = selection(population, fitness)
        next_generation = selected_population[:]
        while len(next_generation) < pop_size:
            parent1, parent2 = random.sample(selected_population, 2)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            next_generation.extend([child1, child2])
        population = next_generation[:]
    best_solutions = sorted(population, key=objective, reverse=True)[:2]  # Get top 2 solutions
    return best_solutions

# Running the Genetic Algorithm
best_solutions = genetic_algorithm(pop_size, num_generations, mutation_rate)

# Printing the result
for i, solution in enumerate(best_solutions, 1):
    print(f"Best solution {i}: {solution}")
    print(f"Objective value at the best solution {i}: {objective(solution)}")