# -*- coding: utf-8 -*-
"""con.noncon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19clgunLSqPX9IGOwdMzpt1onsZ3JFpP1
"""

from scipy.optimize import minimize
import numpy as np

# Define the objective function and constraints
def objective(x):
    return (x[0] - 3)**2 + (x[1] - 2)**2  # Objective function: f(x) = (x1 - 3)^2 + (x2 - 2)^2

def constraint1(x):
    return x[0]**2 - x[1] - 3  # Constraint 1: x1^2 - x2 - 3 >= 0

def constraint2(x):
    return x[1] - 1  # Constraint 2: x2 - 1 <= 0

def constraint3(x):
    return x[0]  # Constraint 3: x1 >= 0

# Define the constraints for the optimization
constraints = ({'type': 'ineq', 'fun': constraint1},
               {'type': 'ineq', 'fun': constraint2},
               {'type': 'ineq', 'fun': constraint3})

# Initial guess for the optimization
x0 = [0.5, 0.5]

# Minimize the objective function subject to the constraints
result = minimize(objective, x0, constraints=constraints)

# Define the Hessian matrix of the objective function
def hessian(x):
    return np.array([[2, 0], [0, 2]])  # Hessian matrix of the objective function

# Check if the optimization problem is convex
def is_convex():
    # Evaluate the Hessian at the optimal solution
    hess_result = hessian(result.x)
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues, _ = np.linalg.eig(hess_result)
    if np.all(eigenvalues >= 0):
        return True
    else:
        return False

# Print whether the problem is convex or non-convex
if is_convex():
    print("The optimization problem is convex.")
else:
    print("The optimization problem is non-convex.")

from scipy.optimize import minimize
import numpy as np

# Define the objective function and constraints
def objective(x):
    return (x[0] - 1.5)**2 + (x[1] - 5)**2  # Objective function: f(x) = (x1 - 1.5)^2 + (x2 - 5)^2

def constraint1(x):
    return -x[0] + x[1] - 2  # Constraint 1: -x1 + x2 <= 2

def constraint2(x):
    return 2*x[0] + 3*x[1] - 11  # Constraint 2: 2x1 + 3x2 <= 11

def constraint3(x):
    return x[0]  # Constraint 3: x1 >= 0

def constraint4(x):
    return x[1]  # Constraint 4: x2 >= 0

# Define the constraints for the optimization
constraints = ({'type': 'ineq', 'fun': constraint1},
               {'type': 'ineq', 'fun': constraint2},
               {'type': 'ineq', 'fun': constraint3},
               {'type': 'ineq', 'fun': constraint4})

# Initial guess for the optimization
x0 = [0.5, 0.5]

# Minimize the objective function subject to the constraints
result = minimize(objective, x0, constraints=constraints)

# Define the Hessian matrix of the objective function
def hessian(x):
    return np.array([[2, 0], [0, 2]])  # Hessian matrix of the objective function

# Check if the optimization problem is convex
def is_convex():
    # Evaluate the Hessian at the optimal solution
    hess_result = hessian(result.x)
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues, _ = np.linalg.eig(hess_result)
    if np.all(eigenvalues >= 0):
        return True
    else:
        return False

# Print whether the problem is convex or non-convex
if is_convex():
    print("The optimization problem is convex.")
else:
    print("The optimization problem is non-convex.")

from scipy.optimize import minimize
import numpy as np

# Define the objective function and constraints
def objective(x):
    return (x[0] - 1)**2 + (x[1] - 1)**2  # Objective function: f(x) = (x1 - 1)^2 + (x2 - 1)^2

def constraint1(x):
    return (x[0] + x[1] - 1)**3  # Constraint 1: (x1 + x2 - 1)^3 <= 0

def constraint2(x):
    return x[0]  # Constraint 2: x1 >= 0

def constraint3(x):
    return x[1]  # Constraint 3: x2 >= 0

# Define the constraints for the optimization
constraints = ({'type': 'ineq', 'fun': constraint1},
               {'type': 'ineq', 'fun': constraint2},
               {'type': 'ineq', 'fun': constraint3})

# Initial guess for the optimization
x0 = [0.5, 0.5]

# Minimize the objective function subject to the constraints
result = minimize(objective, x0, constraints=constraints)

# Define the Hessian matrix of the objective function
def hessian_objective(x):
    return np.array([[2, 0], [0, 2]])  # Hessian matrix of the objective function

# Define the Hessian matrix of constraint 1
def hessian_constraint1(x):
    return np.array([[6*(2*x[0] + x[1] - 1), 6*(x[0] + 2*x[1] - 1)], [6*(x[0] + 2*x[1] - 1), 6*(x[0] + x[1] - 1)]])  # Hessian matrix of constraint 1

# Check if the objective function is convex
def is_convex_objective():
    # Evaluate the Hessian matrix at the optimal solution
    hess_result = hessian_objective(result.x)
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues, _ = np.linalg.eig(hess_result)
    if np.all(eigenvalues >= 0):
        return True
    else:
        return False

# Check if constraint 1 is convex
def is_convex_constraint1():
    # Evaluate the Hessian matrix at the optimal solution
    hess_result = hessian_constraint1(result.x)
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues, _ = np.linalg.eig(hess_result)
    if np.all(eigenvalues >= 0):
        return True
    else:
        return False

# Check if constraints 2 and 3 are convex (they are linear)
def are_convex_constraints():
    return True

# Print whether the problem is convex or non-convex
if is_convex_objective() and is_convex_constraint1() and are_convex_constraints():
    print("The optimization problem is convex.")
else:
    print("The optimization problem is non-convex.")

import numpy as np
from scipy.optimize import minimize
import math

def objective(x):
    return 1 - x[0] + x[1]**2 - 0.1 * math.sin(3 * math.pi * x[0])

def constraint1(x):
    return -x[0] + 0.441  # Upper bound for 'a'

def constraint2(x):
    return x[0] - 0.226  # Lower bound for 'a'

# Define bounds for variables
bounds = [(0, 1.0), (-2, 2)]  # Bounds for x[0] and x[1]

# Define constraints for 'a'
constraints = [{'type': 'ineq', 'fun': constraint1}, {'type': 'ineq', 'fun': constraint2}]

# Initial guess
x0 = np.zeros(2)

# Perform optimization
solution = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)

# Check if the problem is convex or non-convex
def is_convex_hessian(x):
    # Hessian matrix of the objective function
    hessian = np.array([[0.3 * (math.pi)**2 * math.cos(3 * math.pi * x[0]), 0],
                        [0, 2]])
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues = np.linalg.eigvals(hessian)
    return all(eig >= 0 for eig in eigenvalues)

# Print the solution
print("Solution:")
print(solution)

# Check if the problem is convex or non-convex
if is_convex_hessian(solution.x):
    print("The problem is convex.")
else:
    print("The problem is non-convex.")

# 4 og
import numpy as np
from scipy.optimize import minimize
import math

def objective(x):
    return 1 - x[0] + x[1]**2 - 0.1 * math.sin(3 * math.pi * x[0])

def constraint1(x):
    return -x[0] + 0.441  # Upper bound for 'a'

def constraint2(x):
    return x[0] - 0.226  # Lower bound for 'a'

# Define bounds for variables
bounds = [(0, 1.0), (-2, 2)]  # Bounds for x[0] and x[1]

# Define constraints for 'a'
constraints = [{'type': 'ineq', 'fun': constraint1}, {'type': 'ineq', 'fun': constraint2}]

# Initial guess
x0 = np.zeros(2)

# Perform optimization
solution = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)

# Check if the problem is convex or non-convex
def is_convex_hessian(x):
    # Hessian matrix of the objective function
    hessian = np.array([[0.3 * (math.pi)**2 * math.cos(3 * math.pi * x[0]), 0],
                        [0, 2]])
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues = np.linalg.eigvals(hessian)
    return all(eig >= 0 for eig in eigenvalues)

# Print the solution
print("Solution:")
print(solution)

# Check if the problem is convex or non-convex
if is_convex_hessian(solution.x):
    print("The problem is convex.")
else:
    print("The problem is non-convex.")

import numpy as np
from scipy.optimize import minimize
import math

def objective(x):
    return 1 - x[0] + x[1]**2 - 0.1 * math.sin(3 * math.pi * x[0])

def constraint1(x, a):
    return -x[0] + a

# Define bounds for variables
bounds = [(0, 1.0), (-2, 2)]  # Bounds for x[0] and x[1]

# Initial guess
x0 = np.zeros(2)
a = 0.226

# Define constraint
constraint = {'type': 'ineq', 'fun': lambda x: constraint1(x, a)}

# Perform optimization
solution = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraint)

# Check if the problem is convex or non-convex based on the Hessian matrix of the objective function
def is_convex_hessian(x):
    # Hessian matrix of the objective function
    hessian = np.array([[0.3 * (math.pi)**2 * math.cos(3 * math.pi * x[0]), 0],
                        [0, 2]])
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues = np.linalg.eigvals(hessian)
    return all(eig >= 0 for eig in eigenvalues)

# Print the solution
print("Optimal Solution:")
print("x1:", solution.x[0], "x2:", solution.x[1])
print("Objective Value:", solution.fun)

# Check if the problem is convex or non-convex
if is_convex_hessian(solution.x):
    print("The problem is convex.")
else:
    print("The problem is non-convex.")



#4
import numpy as np
from scipy.optimize import minimize
import math

def objective(x):
    return 1 - x[0] + x[1]**2 - 0.1 * math.sin(3 * math.pi * x[0])

def constraint1(x, a):
    return -x[0] + a

# Define bounds for variables
bounds = [(0, 1.0), (-2, 2)]  # Bounds for x[0] and x[1]

# Initial guess
x0 = np.zeros(2)
a = 0.226

# Define constraint
constraint = {'type': 'ineq', 'fun': lambda x: constraint1(x, a)}

# Perform optimization
solution = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraint)

# Check if the problem is convex or non-convex based on the Hessian matrix of the objective function
def is_convex_hessian(x):
    # Hessian matrix of the objective function
    hessian = np.array([[0.3 * (math.pi)**2 * math.cos(3 * math.pi * x[0]), 0],
                        [0, 2]])
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues = np.linalg.eigvals(hessian)
    return all(eig >= 0 for eig in eigenvalues)

# Print the solution
print("Optimal Solution:")
print("x1:", solution.x[0], "x2:", solution.x[1])
print("Objective Value:", solution.fun)

# Check if the problem is convex or non-convex
if is_convex_hessian(solution.x):
    print("The problem is convex.")
else:
    print("The problem is non-convex.")



!wget -qO - https://julialang-s3.julialang.org/bin/linux/x64/1.7/julia-1.7.0-linux-x86_64.tar.gz | tar -xz -C /usr --strip-components 1

import numpy as np
from scipy.optimize import minimize
import math

def objective(x):
    return 1 - x[0] + x[1]**2 - 0.1 * math.sin(3 * math.pi * x[0])

def constraint1(x):
    return -x[0] + 0.441  # Upper bound for 'a'

def constraint2(x):
    return x[0] - 0.226  # Lower bound for 'a'

# Define bounds for variables
bounds = [(0, 1.0), (-2, 2)]  # Bounds for x[0] and x[1]

# Define constraints for 'a'
constraints = [{'type': 'ineq', 'fun': constraint1}, {'type': 'ineq', 'fun': constraint2}]

# Initial guess
x0 = np.zeros(2)

# Perform optimization
solution = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)

# Check if the problem is convex or non-convex based on the Hessian matrix of the objective function
def is_convex_hessian(x):
    # Hessian matrix of the objective function
    hessian = np.array([[0.3 * (math.pi)**2 * math.cos(3 * math.pi * x[0]), 0],
                        [0, 2]])
    # Check if the Hessian matrix is positive semidefinite
    eigenvalues = np.linalg.eigvals(hessian)
    return all(eig >= 0 for eig in eigenvalues)

# Print the solution
print("Solution:")
print(solution)

# Check if the problem is convex or non-convex
if is_convex_hessian(solution.x):
    print("The problem is convex.")
else:
    print("The problem is non-convex.")

# 5

import numpy as np

# Function to compute the second derivative of |sin(pi*x)|
def second_derivative(x):
    return -np.pi**2 * np.sin(np.pi * x)

# Domain of the function
domain = np.linspace(0, 2, 1000)

# Compute second derivative at each point in the domain
second_derivatives = second_derivative(domain)

# Check if second derivative is non-negative in the domain
is_convex = all(second_derivatives >= 0)

if is_convex:
    print("The function |sin(pi*x)| is convex in the interval [0, 2].")
else:
    print("The function |sin(pi*x)| is non-convex in the interval [0, 2].")

import numpy as np

# Function to compute the Hessian matrix of |x^2 * sin(pi*x)|
def hessian_matrix(x):
    return np.array([[2*np.pi**2 * x**2 * np.sin(np.pi * x) + 4 * np.pi**2 * np.cos(np.pi * x),
                      -2 * np.pi * x * np.cos(np.pi * x)],
                     [-2 * np.pi * x * np.cos(np.pi * x),
                      2 * np.sin(np.pi * x) - 2 * np.pi**2 * x**2 * np.sin(np.pi * x)]])

# Domain of the function
domain = np.linspace(0, 2, 1000)

# Compute the Hessian matrix at each point in the domain
hessians = np.array([hessian_matrix(x) for x in domain])

# Check if all Hessian matrices are positive semidefinite
is_convex = all(np.all(np.linalg.eigvals(h) >= 0) for h in hessians)

if is_convex:
    print("The function |x^2 * sin(pi*x)| is convex in the interval [0, 2].")
else:
    print("The function |x^2 * sin(pi*x)| is non-convex in the interval [0, 2].")